# Språkdagbok
- 13/2 Vi satt tillsammans och forskade kring vilket språk vi skulle skapa och kom fram till en imperativ klon som är en hybrid mellan c++ och python. Vi skrev klart språkspecifikation v1.

- 21/2 Inför språkspecifikation v2 fyllde vi ut och tog bort vissa saker. Vi bytte exempelvis ut for-loopar till while-loopar. Det är lite svårt att skriva en språkspec utan att riktigt veta hur språket ska implementeras så det känns lite som en gissningslek i såhär tidigt skede.

- 27/2 Efter duggan i tdp007 på morgonen har vi suttit och skrivit BNFen då vi missuppfattade grammatik-delen av språkspecifikationen inför V2. Vi lade även till lite tankar kring scope-hantering med hänsyn till frames i språkspecen. Detta har tagit en stor del av förmiddagen och på eftermiddagen har vi suttit och skrivit ett utkast till implemenationsplanen.

- 22/3 Idag gick vi igenom samtliga kaptiel av SMoL tutor, några delar var nyttiga för projektet.

- 25/3 Vi har under förmiddagen idag börjat att implementera programmeringsspråket. En stor del av tiden gick till att försöka förstå vart vi skulle börja. Vi anväde oss av projektidéerna på kurshemsidan för att få en humm om vad vi skulle uppnå. De vi hann göra idag var att skapa filer för klasserna Node och Scope som ska vara byggstenarna för språket.

- 26/3 Idag har vi jobbat vidare på att implementera språkets grammatik. Det har varit väldigt svårt att veta från vilket håll man ska börja då det känns som man behöver ha en tanke om hur alla komponenter ska se ut och hänga ihop för att göra det. Vi har dock valt att avgränsa oss till att försöka få enkla matematiska operationer att fungera, då kan vi bygga vidare på det. Detta innebar att vi behövde implementera grammatiken och noderna som ska representera alla tal/variabler och operationer. Vi märkte att några saker saknades i BNFen och vi har justerat dessa. Under eftermiddagen lyckades vi få den enkla matematiken att fungerar(Kanske) men scope-stacken fungerar inte, det finns alltså inga omgivningar och programmet evalueras på ett lite fult sätt.

- 27/3 Idag har vi justerat implementeringen av aritmetiska uttryck. Vi hade ett problem där "**" inte fungerade och löste det genom att ändra ordningen i tokens, detta löste även problemet att "!=" inte fungerade då "!" konsumerades av not-token.Ännu ett problem var associativiteten för negativa uttryck och "-1--1" gav inte väntat resultat. Vi justerade regeln för minus-operationen och löste problemet. Vi även har skrivit enhetstester för den kod vi har hunnit implementera och vi har fått variabeltilldelning och variabel-anrop att fungera under eftermiddagen. 

- 28/3 Under morgonen fortsatte vi på samma del som under gårdagen men kom allt eftersom fram till att vi behövde förändra hur vi tacklade problemet med att bygga AST. Vi hade en blandning av AST och kod som kördes i parsern och när vi försökte implementera if-satser märkte vi att vår scope-hantering inte fungerade. Vi Började om från början med de enkla matematiska uttrycken och skapade denna gåg noder för uttryck och körde koderna i eval för dessa noder istället.

- 2/4 Idag arbetade vi under förmiddagen med att implementera if-satser och while-loopar. Dessa var relativt enkla att implementera och vi använde oss utav rubys if- och while-satser inom "evaluate" funktionerna för båda noderna. Vi stötte även på ett problem när vi körde tester för !-operatorn. Detta för att vi behövde evaluera ihopsättningen av !-tecknet och det logiska uttrycket. Mot slutet av dagens pass upptäckte vi ett problem när vi försökte implementera funktionsdefinitioner, och detta problem fanns också i vår implementation av and/&& och or/||, vilket vi missade p.g.a. bristande tester, vilket vi ska vara mer nogranna med framöver.

- 3/4 Idag har vi arbetat med funktionsdefinitioner och funktionsanrop. Vi började med funktionsdefinitioner och fick det ganska snabbt att fungera, funktionsanrop var däremot krågligare. När vi hade fått kod att köras innuti lagrade fuktioner kom vi fram till att vi behövde skapa returer av data, vilket vi har skjutit på ett tag. Detta krävde en omarbetning av vilka värden en statement list skulle returnera och vi behövde även skapa en ny nodklass för returer. Vi har diskuterat en del under dagen och kommit fram till en del saker vi måste göra i framtiden och vi har därför skapat oss en "todo"-lista. Till nästa gång ska vi börja implementera en lösning för att kunna skapa flera typer av variabler, just nu kan man endast skapa int.

- 4/4 Denna dag började vi med att lägga till funktionaliteten för att skapa varaibler av andra datatyper än "int", vi har nu "int", "float", "char" och "bool". Efter det diskuterade vi hur ett uttryck där en av variablerna var av typen "int" och den andra "float" och kom fram till att vi gör som C++. Om ett av talen i ett uttryck är en flaot, kommer automatiskt den andra göras om till en float och returvärdet kommer därför också vara en float. 3/2 kommer bli 1 då båda är "int" och 3.0/2 blir 1.5. Därefter implementerade vi en "huvudfil" för vårt språk som låter användarna köra språket i interaktivt läge eller köra en programfilskod (med .gph som filändelse). Vi ändrade för tillfället funktioner till att behöva ta in vilken returtyp funktionen har för att lösa en del problem med rekursion. Vi märkte att vid implementering av en mer avancerad rekursion fungerar inte vår nuvarande evaluering av "statement-list" för att bryta körning för det nuvarande scopet och vi ska tackla detta imorgon.

- 5/4 Löste "rekursionsproblem" som visade sig vara statement-list problem. Diskuterade kring chars/strings och om dem behövs ha med. Vi diskuterade även vilka funktioner våra array-datatype ska ha och kom fram till att dem ska ha add, remove, get/change. Vi började därefter implementera arrayer och skapade assignments/fristående arrays.

- 8/4 Under eftermiddagen implementerade vi medlemsfunktioner för Array-datatypen, nämligen add, remove och åtkomst av ett värde inom Arrayen m.h.a [index]. När vi implementerade remove funktionen dök diskussionen upp om vad som ska hända när man kör .remove() funktionen i en tom Array. Vi kom fram till att vi måste diskutera vidare på ett framtida pass. Nästa gång ska vi börja implementera auto-datatypen, vilket ska kunna automatiskt ange datatypen för en variabel. Vi har en ursprunglig tanke som går ut på att basera datatypen på högerledets datatyp som sätts efter lexern skapar en Node_datatype och har avgjort datatypen m.h.a. tokens. Detta skulle innebära en minimal ändring av koden och vara enkelt att implementera.

- 10/4 Dagen började med att debugga ett problem med implementationen av array funktioner när datatypen chars användes. Vi lät ruby evaluera värdet som var lagrat i arrayen, vilket fungerade för resterande datatyper, men vi lagrade chars med "'" tecken runt och ruby tog då bort dessa. Under eftermiddagen implementerade vi auto och detta var i princip lika enkelt som förväntat, minimal justering behövdes göras då vi kunde evaluera returnoden i get_type funktionen som användes i auto datatypen. Vi har även implementerat firstående scopes som fungerar på ungefär samma sätt som funktions-definitions kroppar. Det sista vi löste var att funktioner inte längre behöver defineras med en returtyp, vilket vi hade som ursprunglig tanke kring hur dem skulle skrivas.

- 11/4 Vi började dagen med att ändra hur variabler lagras i dess respektive nod-klasser. Vi gick från att spara alla värden som strängar till att spara dessa som de faktiska värdena. Detta gjorde att vi kunde ta bort flertal "eval"-anrop och minskade potentiella felkällor. Vi skapade negativ- och not-noder istället för att evaluera värdena med ett "-" eller "!" framför (ännu mindre eval androp). Därefter löste vi ett stort problem med vår kod och minskade tiden som gick åt att köra testerna från ~230 sekunder till ~7 sekunder, genom att flytta unary-regeln ovanför atom- istället för under. Vi omarbetade noderna för array funktioner för att undvika nästlade if-satser och gjorde generella förbättringar på kodstrukturen överlag.

- 12/4 Under förmiddagen kom vi fram till att vi behövde specifiera delar av språket i högre detalj. När vi skrev tester kom diskussionen upp om vad som sin ska hända vid uttryck där på vänsterledet och högerledet var arrayer. VI kom fram till att vid aritmetiska uttryck ville vi efterlikna numpys arrayer där man utför beräkningar elementvis, d.v.s [1,2,3] + [1,2,3] blir [4,5,6]. Men för jämförelse uttryck tyckte vi att det det var mer logiskt att hålla sig till hur python hanterar uttryck med arrayer, [1,2,3] > [1,2,3] blir falskt medans [1,2,3,4] > [1,2,3] blir sant. Vi specifierade även att nollor och tomma arrayer hanteras som false i logiska uttryck för att få uttryck som array_a or array_b att på något sätt ge rimlig output.

- 15/4 Idag har vi inte gjort särskilt mycket. Vi fortsatte i förra passets spår och disktureade arrayer och hur de ska fungera i diverse uttryck. En sak vi kom fram till var att aritmetiska uttryck där ena sidan är en array och den andra en int inte ska fungera i vårat språk.

- 17/4 Idag arbetade vi med uttryck med nästlade arrayer, tidigare fungerade inte uttryck som [[1],1] < [[2],1] men vi lyckades lösa detta på ett hyffsat schysst sätt. Det var ganska svårt att förstå de problem som uppstod under implementationen p.g.a den nästlade array-nivån så vi använde oss av många prints. Under eftermiddagen löste vi ungefär samma problem men för "array-accessors" och de funktioner som ska fungera för arrayer om det returnerade värdet skulle vara en array. Alltså: `int[] a = [[1]]; a[0].add(1)` fungerar nu! Allt detta bestämde vi efter en diskussion om vi skulle hålla det simpelt genom att inte lösa array-djup, men vi bestämde oss för att försöka och lyckades ändå.

- 18/4 Under eftermiddagen började vi med grammatiken och specifierade hur parameteröverföringsmetoder ska fungera. Följande metoder kom vi fram till att vi ska implementera: to_c(to char), to_i(to int), to_f(to float) och to_b(to bool). Följande resultat har vi tänkt ska produceras när olika datatyper skickas in: to_i(true) = 1, to_f(true) = 1.0, to_c(true) = t; to_c(500) = '5', to_b(500) = true, to_f(500) = 500.0; to_i(505.5) = 505, to_b(505.5) = true, to_c(505.5) = '5'; to_b(0) = false, to_b(0.0) = false; Vi har bestämt oss att börja med dessa och i mån av tid arbeta på metoder för arrayer.

- 19/4 Vi arbeta idag med att implementera typhärledningar vilket visade sig vara mycket enklare än tidigare tänkt. En diskussion dök upp om hur chars ska konverteras till int, då det inte riktigt fanns något logiskt sätt att lösa detta kollade vi hur andra programmeringsspråk gjorde det. Ruby gjorde allting till 0:or om inte det var en annan siffra, medans python spottar ut et TypeError om man skickar in en char som inte är en siffra, vilket vi valde att efterlikna i vårt språk. Efter detta insåg vi att typkonverteringar för arrayer inte skulle vara några problem heller så vi gjorde både godtycklig datatyp till array, men höll oss till hur python hanterar arrayer till godtycklig datatyp: inte alls.

- 25/4 Vi upptäckte oväntat många kallelser till vår function_call funktion vid rekursiva funktionsanrop, specifikt när vi försökte beräkna fibonacci tal. Vi klurade länge på hur vi skulle lösa det och kom fram till att vi skulle implementera en metod från kursen tdp015 som vi läser parallellt med denna och denna metod kallas "memoization". På detta vis skulle vi kunna lagra vad resultatet blir när man kallar en funktion med ett visst tal, för att undvika att göra beräkningarna igen när man kallar på funktionen med samma värden. Detta var inte för svårt att implementera och gjorde att vi kunde beräkna fibonacci(15) på 0.5s istället för 300s som det tog innan.